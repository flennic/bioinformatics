---
title: "Lab 2 - Gr. 14 - Bioinformatics (732A93)"
output: pdf_document
link-citations: true
author: Andreas Stasinakis (andst745), Hector Plata (hecpl268), Julius Kittler (julki092), Mim Kemal Tekin (mimte666), Stefano Toffol (steto820)
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(fig.width = 7, fig.height = 3, echo = FALSE, 
                      warning = FALSE, message = FALSE) 

library(dplyr)
library(tidyr)
library(magrittr)
library(ape)          # This is a general R-package for phylogenetics 
                      # and comparative methods
library(seqinr)       # This is an specialized package for 
                      # nucleotide sequence management
library(phangorn)
library(knitr)
library(markovchain)  # For fitting, evaluating markov chains (question 2)

```

# Assignment 1

## Question 1.1

```{r A1Q1_start, include=FALSE, echo=FALSE}
source("732A51_BioinformaticsHT2018_Lab02_GenBankGetCode.R")
```


Starting from 33 DNA sequence of various species of casque-headed lizard (Basiliscus basiliscus), other 33 sequences of nucleotides have been generated. The sampling probabilities are the same of the real proportions of the original dataset.  
After the artificial DNA has been created, the base frequencies are compared in Table 1. As expected, the observed proportions of the generated data closely resamble the theoretical ones.


```{r A1Q1, fig.align="center", echo=FALSE}

# ------------------------------------------------------------------------------
# Question 1.1
# ------------------------------------------------------------------------------

lizards_format_sequences = read.fasta(file = "lizard_seqs.fasta")  
# Alternative version of the file. Useful in some ways?

n = length(lizards_accession_numbers)  # Number of sequences to reproduce
p = base.freq(lizards_sequences)  # Probability of the base sequences
simulated_lizards = list()  # Object that will contain our simulated data

# The names of the simulated data are the original names + "_sim"
# NOTE: it does not follow the format from GenBank
simulated_names = paste(lizards_accession_numbers, "_sim", sep = "")  

set.seed(1535)  # Set seed in order to reproduce the experiment
for(i in 1:n) {  # Cycle through every single object of the lizard_sequences
  len_seq = length(lizards_sequences[[i]])  # Lenght of each sequence
  simulated_lizards[[ simulated_names[i] ]] = 
    sample(c("a", "c", "g", "t"), len_seq, replace = T, prob = p)
  # Creating the artificial sequence sampling with probabilities p 
  # that are equal to the original ones. 
  # NOTE: we use the general distribution for every single sequence
}

# Save as fasta file
write.dna(simulated_lizards, file = "simulated_lizards.fasta", format = "fasta", 
          append = F, nbcol = 6, colsep = " ", colw = 10)

# Table with simulated base frequency
df_table = data.frame("Base" = c("a", "c", "g", "t"), 
                       "Original\nfrequency" = p,
                       "Simulated\nfrequency" = 
                        base.freq(as.DNAbin(simulated_lizards)), 
                       row.names = NULL)
kableExtra::kable(df_table, booktabs = T, align = c("r", "l", "l"), digits = c(NA, 4, 4),
      col.names = c("Base", "Original\nfrequency", "Simulated\nfrequency"), 
      format = "latex", caption = "Base frequencies of the 33 original and 
      generated DNA sequences.")

```

## Question 1.2

* Created one phylogenetic tree with 33 tips

* For each original DNA sequence of the 33 available, used the function `simSeq(.)` from package `phangorn` to simulate the sequences.

* Result: 33 phylogenetic tree, one for DNA sequence, each with 33 tips. 

```{r}

# ------------------------------------------------------------------------------
# Question 1.2
# ------------------------------------------------------------------------------

# Simulate phylogenetic tree with 33 tips in phylo format (ape) ----------------
set.seed(1)
tree = ape::rtree(n = 33)

# Plot resulting tree ----------------------------------------------------------

plot(tree, edge.width = 1, main = "Plot of simulated phylogenetic tree")
# phytools::plotTree(tree) # Alternative

# Simulate sequences on this tree using phangorn::simSeq() ---------------------
Q = matrix(c(.1, .8, .05, .05, 
             .35, .1, .1, .45,
             .3, .2, .2, .3,
             .6, .1, .25, .05), nrow = 4, byrow = TRUE)
rownames(Q) = c("a", "c", "g", "t")
colnames(Q) = c("a", "c", "g", "t")

Original = p

tree_sequences_sim = phangorn::simSeq(tree, l = 2000, Q = Q, bf = Original)

# Explanation of parameters: 
# l = 2000 because average sequence length in given data is ca. 2000 
# bf = Original because this is the vector with the original base proportions
# Q = just chosen the matrix from Special Exercise 1 (Question 3)

# Convert to DNAbin
tree_sequences_sim = as.DNAbin(tree_sequences_sim)

# Save simulated sequences as fasta file ---------------------------------------

# Write simulated lizard sequences as fasta file
ape::write.dna(tree_sequences_sim, file ="lizard_seqs_tree_sim.fasta", format = "fasta", 
               append = FALSE, nbcol = 6, colsep = " ", colw = 10)

# Report base composition ------------------------------------------------------

# Table with simulated base frequency
df_table = data.frame("Base" = c("a", "c", "g", "t"), 
                       "Original\nfrequency" = Original,
                       "Simulated\nfrequency" = base.freq(tree_sequences_sim), 
                       row.names = NULL)

kableExtra::kable(df_table, booktabs = T, align = c("r", "l", "l"), digits = c(NA, 4, 4),
      col.names = c("Base", "Original\nfrequency", "Simulated\nfrequency"), 
      format = "latex", caption = "Base frequencies of the 33 original DNA 
      sequences and of the 33 simulated phylogenetic trees.")

```

# Assignment 2

## Question 2.1

**1. Some basic statistics on each sequence dataset:**

```{r}
# ------------------------------------------------------------------------------
# Question 2.1
# ------------------------------------------------------------------------------

# First read in all the data again
original = ape::read.FASTA(file = "data/lizard_seqs.fasta", type = "DNA")
sim_sample = ape::read.FASTA(file = "data/simulated_lizards.fasta", type = "DNA")
sim_tree = ape::read.FASTA(file = "data/simulated_lizards_tree.fasta", type = "DNA")

# 1. Some basic statistics on each sequence dataset ----------------------------

# Individual base composition
knitr::kable(data.frame(Original = ape::base.freq(original), 
             Simulated_Sample = ape::base.freq(sim_sample), 
             Simulated_Tree = ape::base.freq(sim_tree)), 
             caption = "Base composition")
     
# GC content
knitr::kable(data.frame(Original = ape::GC.content(original), 
             Simulated_Sample = ape::GC.content(sim_sample), 
             Simulated_Tree = ape::GC.content(sim_tree)), 
             caption = "Percentage of G + C")

# AT content
knitr::kable(data.frame(Original = 1 - ape::GC.content(original), 
             Simulated_Sample = 1 - ape::GC.content(sim_sample), 
             Simulated_Tree = 1 - ape::GC.content(sim_tree)), 
             caption = "Percentage of A + T")

```


**2. Translate nucleotid sequences into protein sequences & report amino acid composition:**

```{r}

# 2. Translate nucleotid sequences into protein sequences & report amino acid comp.

# Create function to obtain amino acid percentages from DNAbin
get_aa_comp = function(DNAbin, relative = TRUE){
  
  # Data conversion to obtain amino distribution
  
  original_amino = ape::trans(DNAbin) # Convert DNAbin to AAbin (amino acids)
  original_amino = as.character(original_amino) # convert AAbin to char list
  original_amino = unlist(original_amino) # convert char list to char vector

  # Report amino acid composition
  
  if (relative == TRUE) {
    # Compute percentages
    metric = as.numeric(table(original_amino)) / length(original_amino)
    names(metric) = names(table(original_amino))
  } else {
    # Compute counts
    metric = as.numeric(table(original_amino))
    names(metric) = names(table(original_amino))
  }

  return(metric)
}

# Obtain percentages by amino acid precentages
Simulated_Sample = get_aa_comp(sim_sample)
Simulated_Tree = get_aa_comp(sim_tree)
Original = get_aa_comp(original)

# Original has an X at second to last position, we need to account for that
# According to docu of ape::trans, this is because of alignment gaps when 
# e.g. the sequence does not have full 3 proteins.
Simulated_Sample = c(Simulated_Sample, X = 0)
Simulated_Tree = c(Simulated_Tree, X = 0)
Original = Original[c(1:(length(Original)-2), length(Original), length(Original)-1)]

knitr::kable(data.frame(Name = c(seqinr::aaa(), "gaps"),
                        Original, 
                        Simulated_Sample,
                        Simulated_Tree),
             caption = "Amino Acid Composition (in %)")
            
```

**3. Obtain number of stop codons in simulated sequences & compare to true seq:**

There are 1270 stop codons in the original sequence, 1298 stop codons in the
simulated sequence without and 1333 stop codons in the simulated sequence with  
trees.

```{r}

# 3. Obtain number of stop codons in simulated sequences & compare to true seq 

Simulated_Sample = get_aa_comp(sim_sample, relative = FALSE)
Simulated_Tree = get_aa_comp(sim_tree, relative = FALSE)
Original = get_aa_comp(original, relative = FALSE)

knitr::kable(t(data.frame(Original = Original["*"], 
               Simulated_Sample = Simulated_Sample["*"],
               Simulated_Tree = Simulated_Tree["*"])),
             caption = "Number of Stop Codons")

```

## Question 2.2

**Expected Markov chain order:**

I would expect order of 2 (or more) for the original data sets because three 
nucleotids code for an amino-acid and since the amino-acids are not fully 
independent in the DNA. Note that the number of required free parameters increases
a lot from 2 to 3 (see below). The larger the number of parameters, the less
reliable the estimated probabilities for the transition matrix will be.

For the simulated data sets, I would expect order of 1 because here, the 
nucleotids are indeed random and should therefore be independent.

Number of free parameters required for order of 1:
$$4 * (4-1) = 12$$
Number of free parameters required for order of 2:
$$4^2 * (4^2-1) = 240$$

Number of free parameters required for order of 3:
$$4^3 * (4^3-1) = 4032$$

Actual number of nucleotids by dataset:

`> length(unlist(original))`

`[1] 65435`

`> length(unlist(sim_sample))`

`[1] 65435`

`> length(unlist(sim_tree))`

`[1] 66000`

**First**, we concatenate the sequences from the three data sets and remove any
characters that are not "a", "c", "g", "t". **Second**, we conduct a Chi-Square test
with the H0: Sequence is of 1st order. The H0 get's rejected for the original 
sequence (since p = 0) but not for the two sampled sequences (as p > 0.05). This
is what we expected: First order Markov chains for the randomly sampled sequence
but second or higher order Markov chains for the original sequence (in which 
dependency exists). 

```{r}

# ------------------------------------------------------------------------------
# Question 2.2
# ------------------------------------------------------------------------------

# 1. Concatenate the sequences from the three data sets and remove any
# characters that are not "a", "c", "g", "t"

original_seq = unlist(as.character(original)) # obtain character vector
original_seq = original_seq[original_seq %in% c("a", "c", "g", "t")] # a, c, g, t

sim_sample_seq = unlist(as.character(sim_sample)) # obtain character vector
sim_sample_seq = sim_sample_seq[sim_sample_seq %in% c("a", "c", "g", "t")] # a, c, g, t

sim_tree_seq = unlist(as.character(sim_tree)) # obtain character vector
sim_tree_seq = sim_tree_seq[sim_tree_seq %in% c("a", "c", "g", "t")] # a, c, g, t

# 2. Assess the order with Chi-Square test

# This test returns a list of the chi-squared value and the p-value. 
# If the p-value is greater than the given significance level, we cannot reject 
# the hypothesis that the sequence is of first order.

cat("Assess the order with Chi-Square test:\n")
cat("Original:\n"); assessOrder(original_seq); cat("\n-------------\n")
cat("Simulated_Sample:\n"); assessOrder(sim_sample_seq); cat("\n-------------\n")
cat("Simulated_Tree:\n"); assessOrder(sim_tree_seq); cat("\n-------------\n")

```

\  
\  

**Third**, we fit 1st order Markov chains for all three data sets. 
Note that we tried to fit a higher order Markov chain for the original 
data set (since this would be appropriate based on the Chi-Square-Test). 
However, the function fitHigherOrder from the markovchain package did not
produce correct transition matrices and we also did not find any other package
that could fit a higher order Markov chain correctly. Therefore, we also fit
a 1st order Markov chain for the original data set.

\  

```{r}
# 3. Fit markov chains

# 1st order markov chains for sampled data --------------------------------------

original_fit = markovchainFit(data = original_seq, confidencelevel = 0.95,
                              name = "Original")
original_fit$estimate; cat("\n-------------\n")

sim_sample_fit = markovchainFit(data = sim_sample_seq, confidencelevel = 0.95, 
                              name = "Simulated_Sample")
sim_sample_fit$estimate; cat("\n-------------\n")


sim_tree_fit = markovchainFit(data = sim_tree_seq, confidencelevel = 0.95, 
                              name = "Simulated_Tree")
sim_tree_fit$estimate


# Fitting higher order markov chains did not work
# original_fit_2nd = fitHigherOrder(original_seq, order = 2)
# cat("Original, 2nd order:\n\n"); original_fit_2nd; cat("\n-------------\n")

```

\  
\  

**Lastly**, we consider the assumptions behind the analyses (see book 
"Statistical Methods in Bioinformatics"):

1. *Markov property*: "current state is all that matters in determining the 
probabilities for the states that the process will occupy in the future.
2. *Temporally homogenous transition probabilities property*: given that at 
time t, the process is in state $E_{j}$, the probability that one time unit
later it is in state $E_{k}$ is independent of t.

We consider nucleotid sequences here. 

1. The *Markov property* may be violated, especially in the original sequence 
because the nucleotids code for amino-acids that will later on be translated into 
proteins. Therefore, one cannot actually assume that the previous nucleotids 
don't matter in determining the probabilities for the next states. 

2. Regarding the second property, we don't consider time here but space (i.e.
position of the nucleotids). From my point of view, it is a valid assumption 
that the position does not matter (however the type of the previous nucleotids 
does, see 1.).

\  

## Question 2.3

1. Choose a distance measure between sequences.
2. Calculate for each alignment the distances between all pairs of sequences. 
3. Plot heatmaps visualizing the distances. 
4. Comment on what you can observe.

```{r}
# ------------------------------------------------------------------------------
# Question 2.3
# ------------------------------------------------------------------------------

```

# Question 3

## Question 3.1

```{r}
# ------------------------------------------------------------------------------
# Question 3.1
# ------------------------------------------------------------------------------

```

## Question 3.2

```{r}
# ------------------------------------------------------------------------------
# Question 3.2
# ------------------------------------------------------------------------------

```

# Appendix

```{r, ref.label = knitr::all_labels(), echo = TRUE, eval = FALSE}

```